## "Документация" просто чтоб было легче разобраться

### Планировщик ордеров
  - `SinglePendingScheduler` — один «активный» ордер, пока не выполнится запланированный 
  ордер, второй планироваться не будет (ждём задержку).
  - `HeapScheduler` — запланированные ордера хранятся в приоритетной очереди, приоритет на 
  запланированном времени исполнения, то есть у нас в куче может лежать хоть 100 ордеров и ждать свою задержку

    В случае с параллельным планированием была проблема, что при большом времени исполнения,
    в куче накапливалось много ордеров. И если у нас хай банк, то, к примеру: первый 
    ордер мог выкупить всю ликвидность, а второй ордер уже был отправлен и отменить его нельзя (ждёт задержку),
    стакан ещё не обновился, соответственно второму ордеру нехватает ликвидности, и это ведёт у убыточной сделку.
      
    <br>
    
    Эту проблему я решил с помощью виртуального стакана

### Типы стаканов

  - `PlainBooksView` — обычный стакан, проксирует OrderBook.
  - `VirtualBooksView` — как раз поддерживает виртуальную ликвидность, а именно "держит в голове"
    наши запланированные, но ещё не исполненные ордера.


### Запуск торговли

  - `DeterministicRunner` — торговля идёт чисто по стакану, то есть мы никак не связаны с реальным 
    временем, просто идём по данным (стаканам) и берём время оттуда.
  - `RealtimeRunner` — подумал, что первый вариант странный и добавил имитацию реального времени, в контексте 
  данной задачи получилось немного кривовато, но зато ближе к реальности.

    <br>
    Не знал как правильно, поэтому оставил два варианта, плюс получилась неплохая абстракция
    для расширения программы, вдруг кто-то захочет сделать кастомный раннер.


### SynchronizedMarketData
  Класс, который контролирует когда обновлять стаканы, осуществляет работу с данными.
  Решил аж вынести в отдельный слой, так как это единственный класс, работающий с данными. Конечно в данной задаче можно было
  вообще не выносить эту логику даже в отдельный класс и оставить её в самих раннерах, 
  но в итоге получилась расширяемая структура, можно написать уже 
  реальное получение данных с бирж, определить нужные методы (из протокола) и всё будет работать.

### OrderBook 
  Непосредственно сам стакан. Тут вроде ничего интересного, все методы примитивные.
  Из-за того, что не вижу полную картину, не знал, стоит ли делать отдельные классы стаканов под каждую биржу, оставил так.

### ArbStrategy
  Опираясь на стакан, проверяем есть ли спред и если он есть (с учётом всех комиссий), то возвращаем
  сделку. Опять же ничего интересного. В будущем нужно будет добавить абстракцию, для кастомных стратегий.
  Я это не делал, не стал придумывать свою стратегию, а абстрактный класс с единой реализацией смотрится странно.

### ExecutionSimulator
  Симулятор исполнения сделки. Тут считаю нужным пройтись подробнее.

  - `submit_pair_order` — метод ставит пару ордеров (покупка и продажа) в очередь
  - `hedge` — метод моментального хеджирования. Если у уже отправленного ордера не хватило ликвидности,
  например купилось больше, чем продалось, то мы моментально продаём остаток. В моей реализации это возможно при использовании
  параллельного планировщика с дефолтным стаканом.
    
    <br>
    Небольшой комментарий: В данной симуляции работает криво (обычно нехватает ликвидности для хеджа), 
    но я решил не убирать, так как в реальности необходимая фишка. Также, я понимаю, что хеджирование
    нужно выносить в отдельный класс и делать разные типы хеджирования, но так как этого в тз не было, делать не стал
  - `process_pending_up_to` — просто исполняем сделку, ничего интересного

### AppConfig и CliParser
Парсер командной строки, который я сделал чисто для своих костыльных тестов. Оставил его на всякий случай, 
вдруг мне надо будет допилить что-то.

Опять небольшой комментарий: я понимаю, что он максимально некрасивый и неправильный, просто не видел смысла писать хороший
парсер через handler. 

### run_manual
  Просто запуск с ручной настройкой. Не стал парсить торговую пару и название бирж из файлов стаканов, а то получается, что
программа смотрит в будущее, как будто это должно быть в UI

---
При тестировании на маленьких данных скорее всего будет такое, что софт всегда покупает на первой бирже. 
Я долго не мог понять в чём проблема и пришёл к тому, что в питоне криво работает рандом. Если в симуляции данных поменять 
местами порядок генерации стаканов, то всегда будет покупаться на байбите, вместо бинанса.

<br>
С неймингом не стал запариваться и сделал так, как мне удобнее. Насколько я понимаю в каждой компании
свои правила, поэтому не стал что-то выдумывать.

<br>

Ещё не стал писать exception и не оборачивал try: catch:, так как основные ошибки вылетают при работе 
с данными или с пользователем, а этих слоёв нет в тз. Подумал, что нет смысла угадывать возможные ошибки.